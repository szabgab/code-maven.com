=title Ajax request for JSON data
=timestamp 2015-04-25T09:00:01
=indexes XMLHttpRequest, JSON.parse
=status show
=books javascript
=author szabgab
=original ajax-request-for-json-data
=translator name2rnd
=archive 1
=comments_disqus_enable 1

=abstract start

Один из краеугольных камней современных веб-приложений находится за сценой - ассинхронный обмен данными между
сервером и Javascript'ом, работающим в браузере. Хотя Ajax это стандарт для XML, в реальности многие приложения
отправляют данные в формате JSON. В большинстве случаев это удобнее, чем использовать XML.

=abstract end

Чтобы сделать этот пример проще, я создал JSON файл на сервере, который мы будем запрашивать.
В реальной ситуации сервер бы сгенерировал такой JSON по запросу, основываясь на информации в своей базе данных,
но сейчас нам интересна только та сторона, которая работает в браузере.

<include file="examples/js/data.json">

У нас есть HTML страница с элементом <hl>h1</hl>, который мы собираемся заполнить значением ключа "title", 
также есть элемент <hl>div</hl>, для которого мы соберем HTML сниппет.

<try file="examples/js/ajax.html">

JavaScript код выглядит вот так:

<include file="examples/js/ajax.js">

Весь код, относящийся к отправке асинхронного запроса, был помещен в функцию <hl>ajax_get</hl>.
Эта функция принимает два параметра. Первый - URL, который мы запрашиваем. Это может быть URL примерно такой <hl>http://somesite.com/some/page</hl>,
или он может быть без имени хоста, например <hl>/some/page</hl>, если мы хотим отправить запрос на тот же сервер, с которого получили
наш JavaScript. Так же мы можем отправлять параметры, добавляя их после URL. Примерно так: <hl>http://somesite.com/some/page?fname=Foo&lname=Bar</hl>.

Второй параметр - это функция, которая будет вызвана, когда от сервера придет ответ.

В нашем примере мы ожидаем, что ответом будет корректный JSON.

Пройдемся по функции: сначала мы создали объект <hl>XMLHttpRequest()</hl>. Затем мы присвоили атрибуту <hl>onreadystatechange</hl> вызов функции.
Функция будет вызвана, когда прийдет корректный ответ.
Затем мы вызываем <hl>open</hl>, здесь мы используем <hl>url</hl>, и в итоге отправляем запрос функцией <hl>send</hl>. 
Здесь вызов нашей функции завершается и приложение может дальше заниматься своими делами, пока...

Пока сервер не ответит. В этот момент будет вызвана функция, связанная с <hl>onreadystatechange</hl>.
Внутри функции мы проверяем, что запрос действительно был успешным, и затем смотрим на атрибут <hl>responseText</hl>,
который будет содержать ответ в виде текста. В этом примере мы отправляем его в консоль для того, чтобы
видеть, что мы получили. Дальше здесь есть блок <hl>try-catch</hl>, оборачивающий вызов <hl>JSON.parse</hl>.
Это может сэкономить немало времени, если сервер возвратит строку, которая не будет правильным JSON.
(Например, с лишними или пропущенными запятыми). Затем идет интересная часть. Мы вызываем функцию <hl>callback(data)</hl>, которую
<hl>ajax_get</hl> получила вторым параметром, и передаем туда данные (уже в виде JavaScript объекта).

Это что касается реализации функции <hl>ajax_get<hl>, но как нам ее использовать?

<code lang="javascript">
ajax_get('/try/examples/js/data.json', function(data) {
    document.getElementById("title").innerHTML = data["title"];
});
</code>

Мы вызываем функцию <hl>ajax_get</hl>, передавая ей url (относительный к текущему серверу), и мы также передаем функцию,
которая принимает единственную переменную. Это коллбек-функция и ее параметр будет содержать данные, полученные от сервера.
Затем мы можем получить доступ к атрибутам объекта JavaScript также, как и в случае любого другого Javascript объекта,
и устанавливаем атрибут <hl>innerHTML</hl> элемента с id "title".

Вот так мы можем использовать ajax-запрос.

<h2>Сборка HTML</h2>

Вообще-то в нашем примере есть еще код в этой функциии. После установки имени элемента здесь есть пример,
как создать html строку из разных частей этого объекта с данными. Это не обязательно в данном примере,
но я собираюсь использовать эту возможнжость, чтобы продемонстрировать более убедительную причину использовать Handlebars,
про который я рассказывал во <a href="/introduction-to-handlebars-javascript-templating-system">введении в Handlebars</a>.

