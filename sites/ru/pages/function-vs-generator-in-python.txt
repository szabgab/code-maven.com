title Функция vs Генератор в Python
=timestamp 2016-03-19T10:57:01
=indexes yield
=status show
=books python
=author szabgab
=original function-vs-generator-in-python
=translator name2rnd
=archive 1
=comments_disqus_enable 1

=abstract start

Мы посмотрели как сделать <a href="/function-or-callback-in-python">простую функцию и использовать колбек</a>, чтобы сделать функцию более универсальной.
Мы так же посмотрели как <a href="/callback-or-iterator-in-python">создать итератор</a> для упрощения кода.
В этот раз мы собираемся посмотреть как конвертация функции в генератор (после изучения, как это работает)
становится наиболее очевидным решением.

=abstract end

<h2>Простая функция</h2>

В качестве напоминания давайте посмотрим исходную функцию Fibonacci, с которой мы начали,
когда мы должны были жестко описать условие, или в более гибком случае использовать колбек.

<include file="examples/python/fibonacci_function.py">

<h2>Генератор</h2>

<include file="examples/python/fibonacci_generator.py">

Этот пример с генератором почти такой же, как и простая функция, и мы можем его
использовать точно также, как использовали <a href="/callback-or-iterator-in-python">итератор</a>.

Единственное добавление в реализации функции <hl>fibonacci</hl>
это вызов <hl>yield</hl> каждый раз, когда вычислено новое значение.
Этот вызов приостанавливает выполнение функции <hl>fibonacci</hl>
и возвращает управление вызывающей сущности вместе со значением, переданным в оператор <hl>yield</hl>.

В первой итерации цикла <hl>for</hl> функция <hl>fibonacci</hl> начнет работу 
со своего первого оператора создания пустого массива значений <hl>values</hl>.

Когда она встретит оператор <hl>yield</hl>, она вернет значение <hl>values[-1]</hl>, которое
будет присвоено переменной <hl>f</hl> в цикле <hl>for</hl>, дальше цикл <hl>for</hl> продолжит выполнение.
Здесь мы описываем наше условие по прерыванию цикла.

Если мы не прервем выполнение на первой итерации, тогда в последующих итерациях 
цикла <hl>for</hl> функция <hl>fibonacci</hl> продолжит выполнение точно с того места,
где она была приостановлена. Имеется в виду, что содержимое <hl>values</hl>
будет таким же, каким мы его и оставили, а первый оператор, который будет выполнен после вызова <hl>yield</hl>,
это проверка на <hl>True</hl> в операторе <hl>while(True):</hl>.

Таким образом функция <hl>fibonacci</hl> ведет себя точно также, как и <a href="/callback-or-iterator-in-python">итератор Fibonacci</a>,
делая наш код проще.
